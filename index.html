<!doctype html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-startup-image" src="icons/512.png"/>
<link rel="apple-touch-icon">
<title>poker odds</title>
<!--
	Coding style:
		- fatal errors throw
-->
<script src="pokerEngine.js"></script>
<style>
	/* 
	 Main page styles
	https://css-tricks.com/snippets/css/complete-guide-grid/ 
	Single DIV poker chips
	https://codepen.io/pmk/pen/GgrJRq
	Simple PWA starter kit
	https://github.com/nikkifurls/simplepwa/blob/master/style.css
Poker odds
https://www.cardschat.com/poker/strategy/odds/
https://flopturnriver.com/poker-strategy/basic-poker-odds-19146/
Poker book resources:
https://www.holdemresources.net/docs
GTO explanations
https://www.runitonce.com/
Now defunct simulator manual http://propokertools.com/oracle_help/main
	*/
	:root {
		--hilo-button-size: 40px;
		--deck-card-width: 50px;
		--theme-back-color: #fee4d2;
		--felt-green: #C9EED0;
	}
	* {
		box-sizing:border-box;
	}
	html, body {
		margin: 0;
		padding: 0;
	 	min-height: 100vh;/* if body scrolls, can't do drag'n'drop on mobile */
		/* height: 100vh; */
  	/* overflow: hidden; */
		user-select: none;
	}
	/* body {
		background: yellow;
	} */
	.hidden {
		display:none;
	}
	.dragIsActive  {
		touch-action: none;
	}
	#main {
		display: grid;
		background: green;
		grid-template-columns: 1fr;
		grid-template-rows: minmax(max-content, 40px) 1fr minmax(max-content, max-content) max-content;
		grid-template-areas:
			"toolbar"
			"table"
			"deck"
			"stats";
		height:100vh;
		max-height: 1050px;
	}
	@media (min-width: 780px) {
		#main {
			grid-template-columns: 1fr max-content;
			grid-template-areas:
				"toolbar stats"
				"table stats"
				"deck deck";
		}		
	}
	#toolbar {
		grid-area: toolbar;
		/* padding:4px 16px 4px 16px; */
		background: var(--theme-back-color);
		display:flex;
		align-items:center;
		justify-content: center;
		user-select: none;
		padding: 4px;
	}
	#toolbar select {
	font-size:18px;
	}
	#resetButton {
		font-size:24px;
		position:absolute;
		left: 16px;
		padding:8px;
		text-decoration: none;
	}

	#pokerTablePanel {
		grid-area: table;
		padding: 16px;
		position: relative;
		max-height: 800px;
		min-height: 415px;
		user-select: none;
	}

	#tableTop {
		display:flex;
		justify-content: center;
		align-items: center;
		align-content:center;
		flex-wrap:wrap;
		gap:4px;
		box-sizing:border-box;
		width:100%;
		max-width:1280px;
		height: 100%;
		max-height: 800px;
		background: var(--felt-green);
		border: 32px solid #F6E6C2 ;
		border-radius:72px;
	}

	@media (min-width: 780px) {
		#tableTop {
			border-radius:144px;
		}	
	}

	#deckPanel {
		grid-area: deck;
		user-select: none;
		/* background: rgb(122, 122, 157); */
		display:flex;
		flex-wrap:wrap;
		align-items:flex-start;
		justify-content: center;
		user-select: none;
	}
	playing-card.deck {
		width: var(--deck-card-width); 
		min-width: 36px;
	}

	/* suit picker */
	#suitPicker .wide {
		display:none;
	}
	@media (min-width: 440px) {
		#suitPicker .wide {
			display:inline-block;
		}	
		#suitPicker .narrow {
			display: none;
		}
	}
	#suitPicker a {
		text-decoration: none;
		color: black;
		font-size:72px;
		display: inline-block;
	}
	#suitPicker a.selected {
		transform:scale(1.2);
	}
	.suitPickerButton {
		font-size:0px;
		height: 68px;
		width: var(--deck-card-width);
	}
	.suitPickerButton span {
		font-size: 44px;
		color:black;
	}
	.suitPickerButton[data-suit='‚ô•'] span, .suitPickerButton[data-suit='‚ô¶'] span {
		color: red;
	}

	#statsPanel {
		grid-area: stats;
		background: rgb(234 254 231);
		min-width: 300px;
		display:flex;
		flex-direction: column;
	}
	.error {
		border: 2px solid red;
		color: rgb(212, 26, 26);
	}
	#simResults {
		overflow: auto;
		/* max-height: 100%; */
		flex-grow: 1;
		background: white;
	}

	/* Stats table */

	.statsTable {
		border-collapse: collapse;
		width:100%;
		font-family:monospace;
		margin-bottom: 8px;
		border-bottom: 1px solid #ddd;
		border-top: 1px solid #ddd;
		user-select: text;
	}
	
	.statsTable td {
		padding: 1px 2px 1px 2px;
		text-align:center;
	}
	.statsTable th {
		text-align: start;
		font-weight: normal;
	}
	.emoji {
		font-size: x-large;
	}
	.x-small {
		font-size: small;
	}
	.statsTable thead tr:nth-child(1) th:nth-child(1) {
		vertical-align:top;
		position: relative;
	}
	.statsTable .playerCountStats {
		position:absolute;
		bottom: 2px;
		right:2px;
	}
	.statsTable thead tr {
		vertical-align: bottom;
	}
	.statsTable .vsMarquee {
		border: 1px solid #ddd;;
	}
	.statsTable.vsTable td {
		border-left: 1px solid #ddd;
		border-right: 1px solid #ddd;		
	}
	.statsWin {
		background-color:#e2f8df;
	}
	.statsLose {
		background-color:#ffeeec;
	}
	.statsSplit {
		background-color:#eee;
	}
	.statsDetails {
		font-size: 11px;
		font-family: sans-serif;
		border-top: 1px solid #ddd;
	}
	.statsDetails tr:nth-child(odd) {
 	 background-color: rgba(220,220,220,0.5);
	}

	.red {
		color: red;
	}
	.cardTextTile {
		font-size:11px;
		display:inline-block;
		border: 0.5px solid gray;
		border-radius: 3px;
		background-color: white;
		padding: 0 2px 0 2px;
	}

	@keyframes dropCancel {
		to {
			transform: translate(0px , 0px);
		}
	}
	.dropCancel {
		animation: dropCancel;
		animation-duration: 0.1s;
	}
	.isDragged {
		opacity: 0.7;
	}
	#hiloCheckbox {
		margin-left: 16px;
		margin-right: 16px;
		position: relative;
		border: 1px solid black;
		border-radius: calc(var(--hilo-button-size) / 2);
		width: var(--hilo-button-size);
		height: var(--hilo-button-size);
		transform: rotateY(0deg);
		transform-style: preserve-3d;
		transition: transform 0.4s;
	}
	#hiloCheckbox.checked {
		transform: rotateY(180deg);
		transform-style: preserve-3d;
		transition: transform 0.4s;
	}
	.hi {
		background-color: black;
		color: white;
	}
	.hilow {
		background-color: white;
		color: black;
		transform: rotateY(180deg);
	}
	.hi, .hilow {
		position:absolute;
		width: var(--hilo-button-size);
		height: var(--hilo-button-size);
		border-radius: calc(var(--hilo-button-size) / 2);
		backface-visibility: hidden;
		white-space: nowrap;
		font-family: sans-serif;
		font-size: smaller;
		text-align: center;
		line-height: var(--hilo-button-size);
		user-select:none;
	}
</style>
<link rel="stylesheet" href="playing_card.css">
</head>
<body>
<div id="main">
	<div id="toolbar">
		<label title="players">üë§ <select id="playerCount" >
			<option>2</option>
			<option>3</option>
			<option>4</option>
			<option>5</option>
			<option>6</option>
			<option>7</option>
			<option>8</option>
			<option>9</option>
			<option selected>10</option>
		</select></label>
		<label><div id="hiloCheckbox">
			<div class="hi">HI</div>
			<div class="hilow">HI-LO</div>
		</div></label>
		<label>Hole cards<select id="holeCardCount">
				<option selected>2</option>
				<option>3</option>
				<option>4</option>
				<option>5</option>
		</select></label>
		<a id="resetButton" href="javascript:UI.clear()" title="clear all">‚ùå</a>
	</div>
	<div id="pokerTablePanel" class="tall">
		<player-hand><!-- 1 --></player-hand>
		<player-hand class="mini"><!-- 2 --></player-hand>
		<player-hand class="mini"><!-- 3 --></player-hand>
		<player-hand class="mini"><!-- 4 --></player-hand>
		<player-hand class="mini"><!-- 5 --></player-hand>
		<player-hand class="mini"><!-- 6 --></player-hand>
		<player-hand class="mini"><!-- 7 --></player-hand>
		<player-hand class="mini"><!-- 8 --></player-hand>
		<player-hand class="mini"><!-- 9 --></player-hand>
		<player-hand class="mini"><!-- 10 --></player-hand>
		<div id="tableTop">
			<div id="flop" style="display:flex;gap:4px">
				<playing-card title="flop" class="community"></playing-card>
				<playing-card title="flop" class="community"></playing-card>
				<playing-card title="flop" class="community"></playing-card>
			</div>
			<div id="turn" style="line-height:0">
				<playing-card title="turn" class="community"></playing-card>
			</div>
			<div id="river" style="line-height:0">
				<playing-card title="river" class="community"></playing-card>
			</div>
		</div>
	</div>
	<div id="deckPanel">
		<playing-card data-rank="2" class="deck" tabindex=0></playing-card>
		<playing-card data-rank="3" class="deck" tabindex=0></playing-card>
		<playing-card data-rank="4" class="deck" tabindex=0></playing-card>
		<playing-card data-rank="5" class="deck" tabindex=0></playing-card>
		<playing-card data-rank="6" class="deck" tabindex=0></playing-card>
		<playing-card data-rank="7" class="deck" tabindex=0></playing-card>
		<playing-card data-rank="8" class="deck" tabindex=0></playing-card>
		<playing-card data-rank="9" class="deck" tabindex=0></playing-card>
		<playing-card data-rank="10" class="deck" tabindex=0></playing-card>
		<playing-card data-rank="J" class="deck" tabindex=0></playing-card>
		<playing-card data-rank="Q" class="deck" tabindex=0></playing-card>
		<playing-card data-rank="K" class="deck" tabindex=0></playing-card>	
		<playing-card data-rank="A" class="deck" tabindex=0></playing-card>
		<div id="suitPicker" style="display:inline-block">
			<div class="wide">
				<a href="javascript:UI.setDeckSuit('‚ô†')" title="spades">‚ô†</a>
				<a href="javascript:UI.setDeckSuit('‚ô•')" title="hearts" style="color:red">‚ô•</a>
				<a href="javascript:UI.setDeckSuit('‚ô¶')" title="diamonds" style="color:red">‚ô¶</a>
				<a href="javascript:UI.setDeckSuit('‚ô£')" title="clubs">‚ô£</a>
			</div>
			<div class="narrow">
				<button class="suitPickerButton"><span>‚ô†</span></button>
			</div>
		</div>
  </div>
	<div id="statsPanel">
		<button onClick="UI.runSimulation()">Simulate</button>
		<div class="error"></div>
		<div id="simResults"></div>
	</div>
</div>

<script>
class PlayingCard extends HTMLElement {
	static observedAttributes = ["data-suit", "data-rank"];

	static SuitToEmoji = new Map([
		['S', '‚ô†'],
		['H', '‚ô•'],
		['D', '‚ô¶'],
		['C', '‚ô£'],
	]);
	static EmojiToSuit = new Map([
		['‚ô†', 'S'],
		['‚ô•', 'H'],
		['‚ô¶', 'D'],
		['‚ô£', 'C']
	]);

	constructor() {
		super();
	}
	connectedCallback() {
	}
	attributeChangedCallback(name, oldValue, newValue) {

	}
	clear() {
		this.removeAttribute('data-suit');
		this.removeAttribute('data-rank');
	}
	// str is in the PokerEngine card format: "2S"
	setValueFromString(str) {
		if (typeof str != 'string' || str.length < 2)
			this.clear();
		else {
			let rank = str[0];
			if (rank == "T")
				rank = "10";
			let suit = PlayingCard.SuitToEmoji.get(str[1]);
			this.setAttribute('data-suit', suit);
			this.setAttribute('data-rank', rank);
		}
	}
	valueAsString() {
		let rank = this.getAttribute('data-rank');
		let suit = this.getAttribute('data-suit');
		if (!rank && !suit)
			return "";
		if (rank == "10")
			rank = "T";
		return `${rank}${PlayingCard.EmojiToSuit.get(suit)}`;
	}
}
customElements.define("playing-card", PlayingCard);

class PlayerHand extends HTMLElement {
	static observedAttributes = ["data-hole-count"]
	connectedCallback() {
	}
	setHoleCardCount(count) {
		let playingCards = Array.from(this.querySelectorAll('playing-card'));
		let currentCards = playingCards.length;
		while (currentCards > count) {
			let el = playingCards.pop();
			el.remove();
			--currentCards;
		}
		while (currentCards < count) {
			this.append(document.createElement('playing-card'));
			++currentCards;
		}
	}
	attributeChangedCallback(name, oldValue, newValue) {
		if (name == 'data-hole-count')
			this.setHoleCardCount(Number.parseInt(newValue));
		else
			console.warn(`Attribute ${name} not handled`);
	}
}
customElements.define("player-hand", PlayerHand);

class UIModel {
	communityCards = [];
	playerCards = [];
	holeCardCount = 2;
	playerCount = 10;
	holeCardRules = 'atMost2';
	scoring = 'high';
	reset() {
		this.communityCards = [];
		this.playerCards = [];
	}
	setPlayerCount(count) {
		this.playerCount = parseInt(count);
		this.playerCards.splice(count);
	}
	setHoleCardCount(count) {
		this.holeCardCount = count;
		for (let p of this.playerCards) 
			p.splice(count);
	}
	setScoring(scoring) {
		if (scoring != 'high' && scoring != 'highlow')
			throw `Illegal scoring value ${scoring}`;
		this.scoring = scoring;
		if (this.scoring == 'high')
			this.holeCardRules = 'atMost2';
		else
			this.holeCardRules = 'exactly2';
	}

	getAllCardsInUse() {
		return new Array(...this.communityCards, ...this.playerCards.flat(2));
	}
	removeCommunityCard(c) {
		let i = this.communityCards.indexOf(c);
		if (i == -1) {
			console.error(`Community card not found ${c} ${this.communityCards}`);
			return;
		}
		this.communityCards.splice(i, 1);
	}
	// except player specified by index
	removeFromPlayers(c, except=-1) {
		for (let i=0; i<this.playerCards.length; ++i) {
			if (i == except)
				continue;
			let ci = this.playerCards[i].indexOf(c);
			if (ci != -1)
				this.playerCards[i].splice(ci,1);
		}
	}
	// Enforces consistent state by removing card from players
	addCommunityCard(card, cardIndex) {
		if (!card) {
			console.error(`null community card ${card}`);
			return;
		}
		let i = this.communityCards.indexOf(card);
		if (i == -1) {	
			// Card not in community
			if (this.communityCards.length <= cardIndex)
				this.communityCards.push(card);
			else
				this.communityCards.splice(cardIndex, 1, card);
		} else { 
			// Card in community, reorder
			this.communityCards.splice(i, 1);
			this.communityCards.splice(cardIndex, 0, card);
		}
		this.removeFromPlayers(card);
	}
	removeCommunityCard(card) {
		if (!card) {
			console.error(`null community card ${card}`);
			return;
		}
		let i = this.communityCards.indexOf(card);
		if (i == -1)
			return; // not there
		this.communityCards.splice(i,1);
	}
	// Enforces consistent state by removing card from other players + community
	addPlayerCard(card, playerIndex, cardIndex) {
		while (this.playerCards.length <= playerIndex)
			this.playerCards.push([]);
		let cards = this.playerCards[playerIndex];
		let ci = cards.indexOf(card);
		if (ci == -1) {
			if (cards.length <= cardIndex)
				cards.push(card);
			else {
				cards.splice(cardIndex, 1, card);
			}
		} else { // card moved within a hand
			cards.splice(ci, 1);
			cards.splice(cardIndex, 0, card);
		}
		this.removeFromPlayers(card, playerIndex);
		this.removeCommunityCard(card);
	}
	removePlayerCard(card, playerIndex) {
		if (!this.playerCards[playerIndex])
			return;
		let ci = this.playerCards[playerIndex].indexOf(card);
		if (ci == -1) {
			console.warn(`removePlayerCard ${card} not there`);
			return;
		}
		this.playerCards[playerIndex].splice(ci, 1);
	}
	updateFromSimStat(stat) {
		for (let p of ["playerCount","holeCardCount", "scoring", "holeCardRules"]) {
			if (stat[p] === undefined)
				console.error("Stats missing property", p);
			this[p] = stat[p];
		}
		// playerCards array is 2-deep, need deeper clone
		this.playerCards = Array.from(stat.playerCards).map( a => Array.from(a));
		this.communityCards = Array.from(stat.communityCards)
	}
}

class PlayerStats {
	player;
	// accumulated statistics
	hi = { win: 0, lose: 0, split: 0};
	low = { 
		winTotal: 0,	// How much money made after splits, etc. Ex: winning only high is 0.5 win.
		winAll:  0, 
		winOnlyHigh: 0, 
		winOnlyLow: 0,
		splitLow: 0,
		splitHigh: 0,
		lose: 0
	};

	winningHandStats = new Map();
	losingHandStats = new Map();
	splitHandStats = new Map();

	constructor(player, scoring) {
		this.player = player;
		this.scoring = scoring;

		for (let k of PokerEngine.HandRank.keys()) {
			this.losingHandStats.set(k, 0);
			this.winningHandStats.set(k, 0);
			this.splitHandStats.set(k, 0);
		}
	}

	recordGame(game) {
		let didWinHigh = false;
		let didLoseHigh = false;
		let didSplitHigh = false;
		if (game.highWinners.indexOf(this.player) == -1) {
			// If player is not the winner
			let t = game.bestHands[0].bestHighHand.type;
			this.losingHandStats.set(t, this.losingHandStats.get(t) + 1);
			++this.hi.lose;
			didLoseHigh = true;
		} else if (game.highWinners.length > 1) {
			// There is more than one winner
			let t = game.bestHands[0].bestHighHand.type;
			this.splitHandStats.set(t, this.splitHandStats.get(t) + 1);
			++this.hi.split;
			didSplitHigh = true;
			didWinHigh = true;
		} else {
			// Player is the only winner
			let t = game.bestHands[0].bestHighHand.type;
			this.winningHandStats.set(t, this.winningHandStats.get(t) + 1);
			++this.hi.win;
			didWinHigh = true;
		}
		if (this.scoring == "highlow") {
			let hasLow = game.lowWinners && game.lowWinners.length > 0;
			let didWinLow = false;
			let didLoseLow = false;
			let didSplitLow = false;
			if (hasLow) {
				if(game.lowWinners.indexOf(0) == -1) {
					didLoseLow = true;
				} else if (game.lowWinners.length > 1) {
					didSplitLow = true;
					didWinLow = true;
				} else {
					didWinLow = true;
				}
			}
			let winHighWorth = (hasLow ? 0.5 : 1) * 1/game.highWinners.length;
			let winLowWorth = (hasLow ? 0.5 : 0) * 1 / game.lowWinners.length;
			let myWinWorth = (didWinLow ? winLowWorth : 0) + (didWinHigh ? winHighWorth : 0);
			if (myWinWorth)
				console.log(myWinWorth);
			this.low.winTotal += (didWinLow ? winLowWorth : 0) + (didWinHigh ? winHighWorth : 0);
			if (didWinHigh && (didWinLow || !hasLow))
				this.low.winAll++;
			if (didWinHigh && (hasLow && !didWinLow))
				this.low.winOnlyHigh++;
			if (didWinLow && !didWinHigh)
				this.low.winOnlyLow++;
			if (didSplitHigh)
				this.low.splitHigh++;
			if (didSplitLow)
				this.low.splitLow++;
			if (!didWinHigh && (!hasLow || !didWinLow))
				this.low.lose++;
		}
	}
}
// Odds testing:
// https://homes.luddy.indiana.edu/kapadia/nofoldem/10_wins.stats
class SimStats {
	// Hand rules
	holeCardCount;
	holeCardRules;
	playerCount;
	scoring;

	// cards
	communityCards;
	playerCards;

	playerStats = [];
	vsMode = false;
	totalGames = 0;

	dbId = Math.random().toString(36).slice(2, 7);

	static fromJson(json){
		let o = JSON.parse(json, (key, value) => {
			try {
				if(typeof value === 'object' && value !== null) {
					if (value.dataType === 'Map') {
						return new Map(value.value);
					}
				}
				return value;
			} catch (e) {
				debugger;
			}
		});
		return Object.assign(new SimStats(), o);
	}
	
	// https://stackoverflow.com/questions/29085197/how-do-you-json-stringify-an-es6-map
	toJson() {
		return JSON.stringify(this, (key, value) => {
			if(value instanceof Map)
    		return {
      		dataType: 'Map',
      		value: Array.from(value.entries()), // or with spread: value: [...value]
    		};
    	return value;
		});
	}

	// in vsMode, stats are collected for all players whose cards
	// are already assigned.
	constructor(pokerEngine, communityCards, playerCards, activePlayers) {
		if (pokerEngine) {
			for (let p of ["holeCardCount", "holeCardRules", "playerCount", "scoring" ])
				this[p] = pokerEngine[p];
		}
		this.communityCards = Array.from(communityCards || []);
		this.playerCards = Array.from(playerCards || []);
		this.playerStats = new Array(this.playerCount);
		this.activePlayers = Array.from(activePlayers || []);
		this.vsMode = this.activePlayers.length > 1;
		this.playerStats[0] = new PlayerStats(0, this.scoring);
		if (this.vsMode) {
			for (let p of this.activePlayers)
				this.playerStats[p] = new PlayerStats(p, this.scoring);
		}
	}

	recordGame(game) {
		++this.totalGames;
		for (let s of this.playerStats) {
			if (s)
				s.recordGame(game);
		}
	}

	asPercent(count, hideZeros=true) {
		let percent = Math.round((100*count / this.totalGames)).toFixed();
		if (hideZeros && percent == 0)
			return "";
		return `${percent}`;
	}

	// Returns array of cards filled in to hole count.
	fillCardsToCount(playerCards, count) {
		if (playerCards && playerCards.length == count)
			return playerCards;
		playerCards = Array.from(playerCards || []);
		while (playerCards.length < count)
			playerCards.push("??");
		return playerCards;
	}

	getPlayerCommunityCardsAsHtml() {
		let EMPTY_CARDS_HTML = "<div class='cardTextTile'>?</div>";
		let playerCards = this.fillCardsToCount(this.playerCards[0], this.holeCardCount);
		let playerCardsHtml = UI.cardsToHtml(playerCards) || SimStats.EMPTY_CARDS_HTML;
		let communityCardsHtml = UI.cardsToHtml(this.communityCards);
		if (communityCardsHtml != "")
			communityCardsHtml = "<br>" + communityCardsHtml;
		return playerCardsHtml + communityCardsHtml;
	}

	renderPlayerCount() {
		if (this.playerCount == 10)
			return "";
		else
			return `<div class='playerCountStats'>${this.playerCount}üë§</div>`;
	}
	
	render() {
		if (this.vsMode) {
			return this.scoring == 'highlow' ? this.renderVsHighLow() : this.renderVsHigh();
		}
		return this.scoring == 'highlow' ? this.renderHighLow() : this.renderHigh();
	}
	// returns HTML string
	renderHigh() {
		let html = `
<table class="statsTable">
	<colgroup></colgroup>
  <colgroup class="statsWin" style="width:35%"></colgroup>
	<colgroup class="statsLose" style="width:35%"></colgroup>
	<colgroup class="statsSplit" style="width:25%"></colgroup>
	<thead>
		<tr>
			<th rowspan="2" onclick="javascript:UI.showStatsHand('${this.dbId}')">
				${this.getPlayerCommunityCardsAsHtml()}
				${this.renderPlayerCount()}</th>
			<td class="emoji">üëç<span class="x-small">%</span></td>
			<td class="emoji">üëé</td>
			<td class="emoji">üòê</td>
		</tr>
		<tr>
			<td>${this.asPercent(this.playerStats[0].hi.win)}</td>
			<td>${this.asPercent(this.playerStats[0].hi.lose)}</td>
			<td>${this.asPercent(this.playerStats[0].hi.split)}</td>
		</tr>
	</thead>
	<tbody class="statsDetails">							
`;
		for (let k of PokerEngine.HandRank.keys()) {
			let wins = this.playerStats[0].winningHandStats.get(k);
			let losses = this.playerStats[0].losingHandStats.get(k);
			let splits = this.playerStats[0].splitHandStats.get(k);
			let total = wins + losses + splits;
			if (this.asPercent(total) == "")
				continue;
			html += `<tr>
				<th>${k}</th>
				<td>${this.asPercent(wins)}</td>
				<td>${this.asPercent(losses)}</td>
				<td>${this.asPercent(splits)}</td>
			</tr>`;
		}
		html += `
	</tbody>
</table>
`;
		return html;
	}

	renderHighLow() {
		let html = `
<table class="statsTable">
	<colgroup></colgroup>
  <colgroup span=4 class="statsWin"></colgroup>
	<colgroup span=2 class="statsSplit"></colgroup>
	<colgroup span=1 class="statsLose"></colgroup>
	<thead>
		<tr>
			<th rowspan="3" onclick="javascript:UI.showStatsHand('${this.dbId}')">
				${this.getPlayerCommunityCardsAsHtml()}
				${this.renderPlayerCount()}</th>
			<td class="emoji" colspan="4">üëç<span class="x-small">%</span></td>
			<td class="emoji" colspan="2">üòê</td>
			<td class="emoji">üëé</td>
		</tr>
		<tr>
			<td>h+l</td>
			<td>all</td>
			<td>high</td>
			<td>low</td>
			<td>high</td>
			<td>low</td>
			<td>all</td>
		</tr>
		<tr>
			<td>${this.asPercent(this.playerStats[0].low.winTotal)}</td>
			<td>${this.asPercent(this.playerStats[0].low.winAll)}</td>
			<td>${this.asPercent(this.playerStats[0].low.winOnlyHigh)}</td>
			<td>${this.asPercent(this.playerStats[0].low.winOnlyLow)}</td>
			<td>${this.asPercent(this.playerStats[0].low.splitHigh)}</td>
			<td>${this.asPercent(this.playerStats[0].low.splitLow)}</td>
			<td>${this.asPercent(this.playerStats[0].low.lose)}</td>
		</tr>
	</thead>
	<tbody class="statsDetails">							
`;
	html += `
	</tbody>
</table>
`;
	return html;
	}

	renderVsHigh() {
		let html = `
<table class="statsTable vsTable">
	<thead>
		<tr>
			<th class="vsMarquee" rowspan="2" onclick="javascript:UI.showStatsHand('${this.dbId}')">
				vs<br>${UI.cardsToHtml(this.communityCards)}
				${this.renderPlayerCount()}</th>
	`;
	// 1st row are each player's cards
	for (let p of this.activePlayers) {
		html += "<td>";
		let splitStr = this.asPercent(this.playerStats[p].hi.split) == "" ? "" : "/split";
		let playerCards = this.fillCardsToCount(this.playerCards[p], this.holeCardCount);
		html += UI.cardsToHtml(playerCards) || SimStats.EMPTY_CARDS_HTML;
		html += `<br>win${splitStr}`;
		html += "</td>";
	}
	html += "</tr><tr>";
	// 2nd row are player's win percentages
	for (let p of this.activePlayers) {
		let wins = this.playerStats[p].hi.win;
		let splitStr = this.asPercent(this.playerStats[p].hi.split);
		if (splitStr != "")
			splitStr = "/" + splitStr;
		html += `<td>${this.asPercent(wins)}${splitStr}</td>`;
	}
	html += `</tr>
		</thead><tbody class="statsDetails">`;
	for (let k of PokerEngine.HandRank.keys()) {
		let self = this;
		let hasValue = this.activePlayers.filter( p => {
			return self.asPercent(self.playerStats[p].winningHandStats.get(k)) != "";
		});
		if (hasValue.length == 0)
			continue;
		html += `<tr><th>${k}</th>`;
		for (let p of this.activePlayers) {
			let wins = this.playerStats[p].winningHandStats.get(k);
			html += `<td>${this.asPercent(wins)}</td>`;
		}
		html += "</tr>";
	}
	html += `</tbody>
	</table>`;
	return html;
	}

	renderVsHighLow() {
		let html = `
<table class="statsTable vsTable">
	<thead>
		<tr>
			<th class="vsMarquee" rowspan="2" onclick="javascript:UI.showStatsHand('${this.dbId}')">
				vs<br>${UI.cardsToHtml(this.communityCards)}
				${this.renderPlayerCount()}</th>
	`;
		// 1st row are each player's cards
		for (let p of this.activePlayers) {
			html += "<td>";
			let splitStr = this.asPercent(this.playerStats[p].hi.split) == "" ? "" : "/split";
			let playerCards = this.fillCardsToCount(this.playerCards[p], this.holeCardCount);
			html += UI.cardsToHtml(playerCards) || SimStats.EMPTY_CARDS_HTML;
			html += `<br>both/high/low/split`;
			html += "</td>";
		}
		html += "</tr><tr>";
		// 2nd row are player's win percentages
		for (let p of this.activePlayers) {
			let wins = this.playerStats[p].hi.win;
			let splitStr = this.asPercent(this.playerStats[p].hi.split);
			if (splitStr != "")
				splitStr = "/" + splitStr;
			html += `<td style="white-space-collapse: discard">
				${this.asPercent(this.playerStats[p].low.winAll, false)}/
				${this.asPercent(this.playerStats[p].low.winOnlyHigh, false)}/
				${this.asPercent(this.playerStats[p].low.winOnlyLow, false)}/
				${this.asPercent(this.playerStats[p].low.splitLow, false)}</td>`;
		}
		html += `</thead>
	</table>`;
		return html;
	}
}

class PokerStorage {
	static STAT_PREFIX = "STAT_";
	static NEXT_STAT_SAVE_INDEX = 1;

	static simStatList = []; // List of current SimStats

	// returns an array of SimStats
	static loadStats() {
		let stats = [];
		let statToKeyMap = new Map();	// Used to sort entries by key
		for (let i=0; i<window.localStorage.length; ++i) {
			let key = window.localStorage.key(i);
			if (!key.startsWith(PokerStorage.STAT_PREFIX))
				continue;
			try {
				// Update next 
				let match = key.match(/STAT_(\d+)/);
				let keyIndex = 0;
				if (match) {
					keyIndex = parseInt(match[1]);
					if (keyIndex != NaN && keyIndex >= PokerStorage.NEXT_STAT_SAVE_INDEX)
						PokerStorage.NEXT_STAT_SAVE_INDEX = keyIndex+1;
				} 
				else {
					console.error("could not parse key", key);
					continue;
				}
				let stat = SimStats.fromJson(window.localStorage.getItem(key));
				statToKeyMap.set(stat, keyIndex);
				stats.push(stat);
			} catch(e) {
				console.error(`Error decoding Json ${key}`);
			}
		}
		stats.sort((a , b) => {
			let aKey = statToKeyMap.get(a);
			let bKey = statToKeyMap.get(b);
			if (aKey < bKey)
				return -1;
			else if (bKey < aKey)
				return 1;
			return 0;
		});
		PokerStorage.simStatList = stats;
		return stats;
	}

	static saveSimStat(stat) {
		let key = PokerStorage.STAT_PREFIX + PokerStorage.NEXT_STAT_SAVE_INDEX;
		while (window.localStorage.getItem(key)) {
			key = PokerStorage.STAT_PREFIX + ++PokerStorage.NEXT_STAT_SAVE_INDEX;
		}
		window.localStorage.setItem(key, stat.toJson());
		PokerStorage.simStatList.push(stat);
	}

	static getStat(statId) {
		for (let s of PokerStorage.simStatList) {
			if (s.dbId == statId)
				return s;
		}
	}
}

class DragDrop {
	static dragSource;	// element
	static dragStartX;
	static dragStartY;
	static dropTarget; // element
	static dropTargetOldSuit;
	static dropTargetOldRank;

	static initDragAndDrop() {
		document.body.addEventListener('pointerdown', DragDrop.handlePointerDown);
		document.body.addEventListener('pointerup', DragDrop.handlePointerUp);
		document.body.addEventListener('pointerleave', DragDrop.handlePointerLeave);
		window.addEventListener("contextmenu", ev => {
			// On mobilie, long touch during drag will trigger context menu.
			if (DragDrop.isDragging())
				ev.preventDefault();
		});
	}
	static handlePointerDown(ev) {
		// console.log('pointerdown', ev);
		// Because player-hands might overlap cards, need to search 
		let dragSource = DragDrop.getDragSource(ev);
		if (!dragSource)
			return;
		DragDrop.startDrag(ev, dragSource);
	}
	static handlePointerUp(ev) {
		// console.log('pointerup');
		DragDrop.endDrag(ev);
	}
	static handlePointerLeave(ev) {
		// console.log('pointerleave');
		DragDrop.endDrag(ev);
	}
	static handlePointerMove(ev) {
		// console.log('pointermove', ev);
		DragDrop.dragMove(ev);
	}
	static isDragging() {
		return DragDrop.dragSource != null;
	}
	static getDragSource(ev) {
		// All playing cards can be dragged
		if (ev.target.tagName == 'PLAYING-CARD' &&
			ev.target.valueAsString() != "")
			return ev.target;
		// Find them even when obscured
		let candidates = document.elementsFromPoint(ev.clientX, ev.clientY);
		for (let c of candidates)
			if (c.tagName == 'PLAYING-CARD' && c.valueAsString() != "")
				return c;
		return null;
	}
	static getDropTarget(ev) {
		let candidates = document.elementsFromPoint(ev.clientX, ev.clientY);
		// console.log(candidates);
		for (let c of candidates)
			if (c.tagName == 'PLAYING-CARD' && c != DragDrop.dragSource) {
				// console.log(c);
				return c;
			}
		return null;
	}

	static isDroppable(el) {
		if (el.nodeName != 'PLAYING-CARD')
			return false;
	}
	static startDrag(ev, dragSource) {
		document.body.addEventListener('pointermove', DragDrop.handlePointerMove);
		document.body.addEventListener('touchmove', UI.preventDefault, { passive: false });
		DragDrop.dragSource = dragSource;
		DragDrop.dragSource.classList.add("isDragged");
		DragDrop.dragStartX = ev.screenX;
		DragDrop.dragStartY = ev.screenY;
		DragDrop.dragSource.style.zIndex = "1";
	}
	static endDrag(ev) {
		document.body.removeEventListener('pointermove', DragDrop.handlePointerMove);
		document.body.removeEventListener('touchmove', UI.preventDefault);
		if (!DragDrop.dragSource)
			return;
		DragDrop.dragSource.classList.remove("isDragged");
		// Workaround for bug with drag'n'drop and click handling
		// Dragged card will also receive a click event because
		// there was a mousedown+mouseup on it.
		// There is no way to prevent 'click' from firing.
		// Therefore, click handler must ignore click if
		// element was just dragged.
		// We signal that element was dragged by setting "wasDragged" class
		if (DragDrop.dropTarget) {
			DragDrop.dragSource.classList.add("wasDragged");
			let dragSource = DragDrop.dragSource;
			window.setTimeout(_ => dragSource.classList.remove("wasDragged"), 0);
		}
		if (DragDrop.dropTarget) {
			UI.moveCardFromElements(DragDrop.dragSource, DragDrop.dropTarget);
			DragDrop.dropTarget = null;
			DragDrop.dropTargetOldSuit = null;
			DragDrop.dropTargetOldRank = null;
			DragDrop.dragSource.style.transform = '';
		} else {
			DragDrop.dragSource.addEventListener('animationend', DragDrop.endDragAnimationEnd);
			DragDrop.dragSource.classList.add("dropCancel");
		}
		// DragDrop.dragSource.style.transform = "";
		DragDrop.dragSource.style.zIndex = "";
		DragDrop.dragSource = undefined;
		DragDrop.dragStartX = undefined;
		DragDrop.dragStartY = undefined;
	}
	static dragMove(ev) {
		if (!DragDrop.dragSource)
			console.error("dragMove, no target!");
		let x = ev.screenX - DragDrop.dragStartX;
		let y = ev.screenY - DragDrop.dragStartY;
		DragDrop.dragSource.style.transform = `translate(${x}px , ${y}px) scale(1.3)`;
		DragDrop.showDropTarget(ev, DragDrop.getDropTarget(ev));
	}
	static showDropTarget(ev, dropTarget) {
		if (dropTarget == DragDrop.dropTarget || dropTarget == DragDrop.dragSource)
			return;
		if (DragDrop.dropTarget) {	// restore old state
			if (!DragDrop.dropTargetOldRank)
				DragDrop.dropTarget.removeAttribute('data-rank');
			else
				DragDrop.dropTarget.setAttribute('data-rank', DragDrop.dropTargetOldRank);
			if (!DragDrop.dropTargetOldSuit)
				DragDrop.dropTarget.removeAttribute('data-suit');
			else
				DragDrop.dropTarget.setAttribute('data-suit', DragDrop.dropTargetOldSuit);
			DragDrop.dropTarget = null;
		}
		if (dropTarget) {
			DragDrop.dropTargetOldRank = dropTarget.getAttribute('data-rank');
			DragDrop.dropTargetOldSuit = dropTarget.getAttribute('data-suit');
			DragDrop.dropTarget = dropTarget;
			let srcRank = DragDrop.dragSource.getAttribute('data-rank');
			let srcSuit = DragDrop.dragSource.getAttribute('data-suit');
			if (!srcRank || !srcSuit) {
				console.error(`dragSource missing attributes ${srcRank} ${srcSuit}`);
				return;
			}
			if (!dropTarget.classList.contains("deck")) {
				DragDrop.dropTarget.setAttribute('data-rank', srcRank);
				DragDrop.dropTarget.setAttribute('data-suit', srcSuit);
			}
		}
	}
	static endDragAnimationEnd(ev) {
		// console.log("Animation ended", ev);
		ev.target.style.transform = '';
		ev.target.classList.remove('dropCancel');
	}
}

class UI {
	static model = new UIModel;
	static lastDestination;	// last move destination

	static init() {
		// window.addEventListener("error", ev => { console.log(ev.message); alert("js error"); });
		document.querySelector("#playerCount").addEventListener('input', UI.playersChanged);
		document.querySelector("#holeCardCount").addEventListener('input', UI.holeCardCountChanged);
		document.querySelector("#hiloCheckbox").addEventListener("click", ev => {
			ev.currentTarget.classList.toggle("checked");
			if (ev.currentTarget.classList.contains("checked"))
				ev.currentTarget.value = "highlow";
			else
				ev.currentTarget.value = "high";
			UI.scoringChanged();
		});
		document.querySelector("#suitPicker .suitPickerButton").addEventListener('click', UI.suitPickerChanged);
		document.querySelector("#hiloCheckbox").value = "high";
		UI.holeCardCountChanged();
		UI.playersChanged();
		UI.scoringChanged();
		UI.setDeckSuit('‚ô•');
		
		DragDrop.initDragAndDrop();
		for (let d of document.querySelectorAll("#deckPanel playing-card"))
			d.addEventListener("click", UI.deckClick);
		UI.initServiceWorker();
		for (let s of PokerStorage.loadStats()) {
			UI.showSimStat(s);
		}
	}
	static showError(msg) {
		let errEl = document.querySelector("#statsPanel .error");
		errEl.classList.remove("hidden");
		errEl.innerText = msg;
	}
	static clearError() {
		document.querySelector("#statsPanel .error").classList.add("hidden");
	}
	static async initServiceWorker() {
		if (!'serviceWorker' in navigator) {
			console.error(`navigator.serviceWorker not found`);
			return;
		}
		navigator.serviceWorker.addEventListener('controllerchange', _ => {
			console.log('event: controllerchange on navigator.serviceWorker ');
			// window.location.reload();
		});
		let registration = await navigator.serviceWorker.register("/serviceWorker.js", { scope: "/", });
	}
	static deckClick(ev) {
		// if card was just dragged, ignore the click
		if (ev.target.classList.contains("wasDragged"))
			return;
		// Click on deck card adds card to last move destination
		let dest;
		if (UI.lastDestination) {
			if (UI.lastDestination.location == 'player') {
				dest = {
					location: 'player',
					playerIndex: UI.lastDestination.playerIndex,
					cardIndex: UI.lastDestination.cardIndex + 1
				}
				if (dest.cardIndex > UI.model.holeCardCount - 1)
					dest.cardIndex = 0;
			} else if (UI.lastDestination.location == 'community') {
				dest = {
					location: 'community',
					cardIndex: UI.lastDestination.cardIndex+1
				}
				if (dest.cardIndex > 4)
					dest.cardIndex = 0;
			}
		}
		if (!dest) {
			dest = {
				location: 'player',
				playerIndex: 0,
				cardIndex: 0
			}
		}
		UI.moveCard(UI.cardAddressFromElement(ev.target), dest);
	}

	static preventDefault(ev) {
		if (ev.cancelable)
			ev.preventDefault();
	}
 	static playersChanged() {
		UI.model.setPlayerCount(document.querySelector("#playerCount").value);
		UI.syncUIToModel();
	}
	static holeCardCountChanged() {
		UI.model.setHoleCardCount(document.querySelector("#holeCardCount").value);
		if (UI.model.holeCardCount == 5 && UI.model.playerCount == 10) {
			document.querySelector("#playerCount").value = 9;
			UI.playersChanged();
			return;
		}
		UI.syncUIToModel();
	}
	static scoringChanged() {
		UI.model.setScoring(document.querySelector("#hiloCheckbox").value);
		if (UI.model.scoring == 'highlow' && UI.model.holeCardCount < 4)
			UI.model.setHoleCardCount(4);
		if (UI.model.scoring == 'high' && UI.model.holeCardCount > 3)
			UI.model.setHoleCardCount(2);
		UI.syncUIToModel();
	}
	static suitPickerChanged(ev) {
		UI.setDeckSuit(ev.currentTarget.innerText);
	}
	static suits = Array.from(PlayingCard.EmojiToSuit.keys());

	static cardToHtml(c) {
		if (!c || c.length < 2)
			throw `cardToHtml got an illegal card ${c}`;
		let rank = c[0];
		let suit = c[1];
		if (rank == "T")
			rank = "10";
		switch(suit) {
			case 'S': 
				suit = "‚ô†";
				break;
			case 'C':
				suit = "‚ô£";
				break;
			case 'H':
				suit = "<span class='red'>‚ô•</span>";
				break;
			case 'D':
				suit = "<span class='red'>‚ô¶</span>";
				break;
			default:
				suit = '?';
				break;
		}
		return `<div class='cardTextTile'>${rank}${suit}</div>`;
	}

	static cardsToHtml(cardsArray) {
		if (!cardsArray)
			return "<div class='cardTextTile'>? ?</div>";
		return cardsArray.map( c => UI.cardToHtml(c)).join('');
	}

	static setDeckSuit(suit) {
		for (let c of document.querySelectorAll("#deckPanel > playing-card")) {
			c.setAttribute("data-suit", suit);
		}
		for (let a of document.querySelectorAll("#suitPicker a")) {
			if (a.innerText == suit)
				a.classList.add("selected");
			else
				a.classList.remove("selected");
		}
		// Update suitPickerButton
		let suitIndex = UI.suits.indexOf(suit);
		if (suitIndex != -1) {
			if (++suitIndex == UI.suits.length)
				suitIndex = 0;
			let button = document.querySelector("#suitPicker .suitPickerButton");
			let span = button.querySelector("span");
			span.innerText = UI.suits[suitIndex];
			button.setAttribute('data-suit', UI.suits[suitIndex]);
		} else {
			console.error(`unexpected suit value ${suit}`);
		}
		UI.syncUIToModel();
	}

	static cardAddressFromElement(el) {
		// address is one of:
		// { location: 'deck'; value: pokerEngineCardValue }
		// { location: 'community'; value: pokerEngineCardValue }
		// { location: 'player'; playerIndex; cardIndex; value: pokerEngineCardValue;  }
		if (el.tagName != 'PLAYING-CARD')
			throw `Unknown card address ${el}`;
		if (el.classList.contains("deck"))
			return {
				location: 'deck',
				value: el.valueAsString()
			};
		if (el.classList.contains("community")) {
			let communityIndex = Array.from(
				document.querySelectorAll("#tableTop playing-card")).indexOf(el);
			if (communityIndex == -1)
				throw `Could not find community card index ${el}`;
			return {
				location: 'community',
				value: el.valueAsString(),
				cardIndex: communityIndex
			};
		}
		// player hand
		let hand = el.parentElement;
		let handCards = Array.from(el.parentElement.querySelectorAll('playing-card'));

		let tableHands = Array.from(document.querySelectorAll('#pokerTablePanel player-hand'));
		if (tableHands.indexOf(hand) == -1)
			throw `Cannot find table hand ${hand}`;
		if (handCards.indexOf(el) == -1)
			throw `Cannot find hand card ${hand}`;
		return {
			location: 'player',
			playerIndex: tableHands.indexOf(hand),
			cardIndex: handCards.indexOf(el),
			value: el.valueAsString()
		}
	}

	static moveCardFromElements(srcEl, destEl) {
		let src = UI.cardAddressFromElement(srcEl);
		let dest = UI.cardAddressFromElement(destEl);
		UI.moveCard(src, dest);
	}
	// src/dest are cardAddresses
	static moveCard(src, dest) {
		UI.lastDestination = dest;
		switch(src.location) {
			case 'deck':
				switch(dest.location) {
					case 'deck':
						break;	// do nothing
					case 'community':
						UI.model.addCommunityCard(src.value, dest.cardIndex);
						break;
					case 'player':
						UI.model.addPlayerCard(src.value, dest.playerIndex, dest.cardIndex);
						break;
				}
				break;
			case 'community':
				switch (dest.location) {
					case 'deck':
						UI.model.removeCommunityCard(src.value);
						break;
					case 'community':
						UI.model.addCommunityCard(src.value, dest.cardIndex);
						break;
					case 'player':
						UI.model.addPlayerCard(src.value, dest.playerIndex, dest.cardIndex);
						break;
				}				
				break;
			case 'player':
				switch (dest.location) {
					case 'deck':
						UI.model.removePlayerCard(src.value, src.playerIndex);
						break;
					case 'community':
						UI.model.addCommunityCard(src.value, dest.cardIndex);
						break;
					case 'player':
						UI.model.addPlayerCard(src.value, dest.playerIndex, dest.cardIndex);
						break;
				}
				break;
		}
		UI.syncUIToModel();
	}

	static syncUIToModel() {
		UI.clearError();

		// Sync toolbar
		document.querySelector("#playerCount").value = UI.model.playerCount;
		document.querySelector("#holeCardCount").value = UI.model.holeCardCount;
		let hiloCheckbox = document.querySelector("#hiloCheckbox");
		hiloCheckbox.value = UI.model.scoring;
		if (UI.model.scoring == "highlow")
			hiloCheckbox.classList.add("checked");
		else
			hiloCheckbox.classList.remove("checked");

		// Only show hands in play, with correct number of hole cards
		let i = 1;
		for (let el of document.querySelectorAll("#pokerTablePanel > player-hand")) {
			if (i++ <= UI.model.playerCount)
				el.style.display = "";
			else
				el.style.display = "none";
			el.setAttribute('data-hole-count', UI.model.holeCardCount);
		}
		// Sync community cards
		let communityElements = document.querySelectorAll("#tableTop playing-card");
		for (let i=0; i<communityElements.length; ++i) {
			if (UI.model.communityCards.length <= i) {
				communityElements[i].clear();
			} else {
				communityElements[i].setValueFromString(UI.model.communityCards[i]);
			}
		}
		// Sync player cards
		let playerHandElements = document.querySelectorAll("#pokerTablePanel player-hand");
		for (let h=0; h<playerHandElements.length; ++h) {
			playerHandElements[h].setAttribute('data-hole-count', UI.model.holeCardCount);
			let cardElements = playerHandElements[h].querySelectorAll("playing-card");
			let cards = UI.model.playerCards[h];
			let hasCards = false;
			for (let c=0; c<cardElements.length; ++c) {
				let cardValue = cards ? cards[c] : undefined;
				if (cardValue)
					hasCards = true;
				cardElements[c].setValueFromString(cardValue);
			}
			if (hasCards)
				playerHandElements[h].classList.remove("closed");
			else
				playerHandElements[h].classList.add("closed");
		}
		// Gray out deck cards that are used
		let allCards = UI.model.getAllCardsInUse();
		for (let el of document.querySelectorAll("#deckPanel playing-card")) {
			if (allCards.indexOf(el.valueAsString()) == -1)
				el.classList.remove("inUse");
			else
				el.classList.add("inUse");
		}
	}

	static showSimStat(simStat) {
		if (!simStat) {
			console.error("syncUIToStats has no stats")
			return;
		}
		if (simStat) {
			let d = document.createElement("div");
			d.classList.add("statsDiv");
			d.innerHTML = simStat.render();
			let target = document.querySelector("#simResults");
			//target.innerHTML = "";
			target.prepend(d);
		}
	}
	
	static showStatsHand(statsId) {
		let stats = PokerStorage.getStat(statsId);
		if (!stats) {
			console.error("Could not show stats ", statsId);
			return;
		}
		UI.model.updateFromSimStat(stats);
		UI.syncUIToModel();
	}

	static runSimulation() {
		console.log("Run simulation");
		for (let s of document.querySelectorAll(".stat"))
			s.innerText = "";
		let engine = new PokerEngine({ 
			playerCount: UI.model.playerCount,
			holeCardCount: UI.model.holeCardCount,
			holeCardRules: UI.model.holeCardRules,
			scoring: UI.model.scoring
		});
		window.setTimeout( _ => {
			let count = 5000;
			let activePlayers = [];
			for (let i=0; i<UI.model.playerCards.length; ++i) {
				if (UI.model.playerCards[i] && UI.model.playerCards[i].length > 0)
					activePlayers.push(i);
			}
			if (activePlayers.length > 0 && activePlayers.indexOf(0) == -1)
				activePlayers.unshift(0);
			// score all players if only active player is 0
			if (activePlayers.length < 2)
				activePlayers = [];

			let stats = new SimStats(
				engine, UI.model.communityCards, UI.model.playerCards, activePlayers);
			let start = Date.now();
		
			try {
				for (let i = 0; i < count; i++) {
					let results = engine.playGame(
						UI.model.playerCards, UI.model.communityCards, activePlayers);
					stats.recordGame(results);
				}
			} catch(err) {
				UI.showError(err);
				console.error(err);
				return;
			}
			let elapsed = Date.now() - start;
			let gameTime = elapsed / count;
			console.log(`${count} games took ${elapsed}ms; ${gameTime}ms per game`);
			UI.showSimStat(stats);
			PokerStorage.saveSimStat(stats);
		}, 0);

	}

	static clear() {
		UI.model.reset();
		UI.lastDestination = undefined;
		UI.syncUIToModel();
		window.localStorage.clear();
		for (let el of document.querySelectorAll(".statsDiv"))
			el.remove();
	}
}

UI.init();
</script>
</body>
